#+title: Implementing Semantic Fragments in Haskell
#+subtitle: HHU spring/summer semester 2023
#+bibliography: ../bibliography/master.bib
#+cite_export: csl
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+OPTIONS: toc:nil
#+EXPORT_FILE_NAME: ./docs/index.html
#+author: Patrick D. Elliott

#+CAPTION: Fernsehturm, Berlin 1968 (Horst Sturm)
#+ATTR_HTML: :width 250 :style border:2px solid black;
[[./fernsehturm.jpg]]

Last updated: "[2023-04-13 11:53]" 

[[./syllabus.pdf][Syllabus]]

* Course description

#+begin_quote
This course is intended primarily as a first introduction to functional programming, aimed at students with an existing background in logic and/or linguistics. The programming language we'll be using in this course is Haskell - a statically-typed, purely functional language, with a focus on referential transparency (don't worry, you'll find out what all of this means if you take the course!). Although not as common as languages such as python, Haskell is a general-purpose programming language with industrial applications (used, e.g., for spam-filtering at Meta). For our purposes, Haskell is especially compelling since its design is inspired by mathematical tools commonly deployed in linguistic theory, such as the lambda calculus, type theory, and category theory. The main topic of this course is "computational semantics", but from a symbolic/algorithmic, rather than a data-driven perspective. Over the course of the semester, we'll gradually build up a working knowledge of Haskell by implementing logical constructs used in linguistics, such as Context Free Grammars and Montagovian fragments as *programs*.

This will be an extremely hands-on course, and students should ideally expect jto bring a laptop to class. We'll set up a Haskell development environment together, and homework exercises will involve concrete programming tasks. 
#+end_quote

* Haskell resources

- Run haskell programs in your browser using the [[https://play.haskell.org/][haskell playground]]. 
- Setting up a haskell environment: [[https://www.haskell.org/get-started/][Get Started]] 
- The [[https://haskellbook.com/][Haskell from first principles]] textbook.

* Schedule

Class takes place *Tuesday 12:30-14:00* in *2321.U1.93 (Z 18)*.

| date     | class                          |
|----------+--------------------------------|
| April 4  | [[*The lambda calculus][The lambda calculus]]    |
| April 11 | [[Hello Haskell!][Hello Haskell!]] |
| April 18 | Datatypes|
| April 25 | Types and typeclasses |
| May 2    | Formal syntax for fragments |
| May 9    | Formal semantics for fragments (remote) |
| May 16   | NO CLASS                       |
| May 23   | Model checking |
| May 30   | Meaning composition |
| June 6   | Functors    |
| June 13  | Applicative functors  |
| June 20  | Monads                         |
| June 27  | Continuation passing style |
| July 4   | project presentations          |
| July 11  | project presentations          |

* Topics

** The lambda calculus

- The slides can be downloaded [[./lambda.pdf][here]].
  * You can also browse the content [[./lambda.html][here]].
- *Homework*: Read chapter 1 of /Haskell from first principles/ [cite:@AllenMoronuki2016] and do the chapter exercises.

** Hello Haskell!

- The (updated) slides can be downloaded [[./hello-haskell.pdf][here]].
  * You can also browse the content [[./hello-haskell.html][here]].
- *Homework*: Read chapters 2 of /Haskell from first principles/ [cite:@AllenMoronuki2016] and do the exercises at the end of chapter 2.
 

* References
  
#+print_bibliography:

* File local variables                                             :noexport:

# Local Variables:
# time-stamp-line-limit: 1000
# time-stamp-format: "[%Y-%m-%d %H:%M]"
# time-stamp-active: t
# time-stamp-start: "Last updated: \""
# time-stamp-end: "\""
# eval: (add-hook 'before-save-hook (lambda () (if (y-or-n-p "update timestamp?") (time-stamp))) nil t)
# eval: (add-hook 'after-save-hook (lambda nil (if (y-or-n-p "export to html?") (org-html-export-to-html))) nil t)
# End:
